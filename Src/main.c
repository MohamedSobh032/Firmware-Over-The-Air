/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include "LSTD_TYPES.h"
#include "LBIT_MATH.h"
#include "MRCC_Interface.h"
#include "MGPIO_Interface.h"
#include "MSTK_Interface.h"
#include "MUSART_Interface.h"
#include "MFMI_Interface.h"
#include "SHPR_Interface.h"
#include "main.h"

/********************************* READ ONLY GLOBAL VARIABLES *********************************/
const p8 CIPSTART = "AT+CIPSTART=\"TCP\",\"69.197.143.14\",80\r\n";
/**********************************************************************************************/


/************************************ VARIABLE DEFINITIONS ************************************/

/************** AT COMMANDS HELPERS **************/
u8 BOOT_u8Buffer = 0;
CONTINUE_FLAG BOOT_ContFlag = 0;
u8 BOOT_u8TimeOut = 0;
/*************************************************/

/******************** ADDRESS ********************/
u32 BOOT_u32Address = 0;
/*************************************************/

/************* DATA RECORDS FETCHING *************/
u8 BOOT_u8CounterD0 = '0';
u8 BOOT_u8CounterD1 = '0';
u8 BOOT_u8CounterD2 = '0';
u8 BOOT_u8DataRecord[115] = {0};
u8 BOOT_u8RecordLength = 0;
/*************************************************/

/**********************************************************************************************/


/************************************ FUNCTION DEFINITIONS ************************************/

/************ INITIALIZATION FUNCTIONS ***********/
void BOOT_vHWReset(void);
void BOOT_vInitESP(void);
void BOOT_vInit(void);
/*************************************************/

/***************** ESP FUNCTIONS *****************/
void BOOT_vGetFirmwareStatusAndAddress(void);
void BOOT_vReceiveDataRecord(void);
void BOOT_vCloseConnection(void);
void BOOT_vUpdateFirmwareStatus(void);
/*************************************************/

/**************** BOOTING SEQUENCE ***************/
void BOOT_vJumpToApplicationCode(void);
/*************************************************/

/**********************************************************************************************/

int main(void) {
	BOOT_vInit();
	BOOT_vGetFirmwareStatusAndAddress();
	if (BOOT_u8Buffer == 'O') { BOOT_vJumpToApplicationCode(); }
	else if (BOOT_u8Buffer == 'N') {
		MFMI_SectorNumber Local_SectorNumber = MFMI_getSectorNumber(BOOT_u32Address);
		if (Local_SectorNumber == MFMI_FALSE_SECTOR || Local_SectorNumber == MFMI_SECTOR_ONE) {
			BOOT_vUpdateFirmwareStatus();
			BOOT_vJumpToApplicationCode();
		} else { MFMI_vSectorErase(Local_SectorNumber); }
		while (true) {
    		BOOT_vReceiveDataRecord();
    		/* Parse and flash */
    		SHPR_vParseHexRecord(&BOOT_u8DataRecord[22]);
    		BOOT_u8RecordLength = SHPR_u8GetRecordLength(&BOOT_u8DataRecord[22]);
    		SHPR_vParseHexRecord(&BOOT_u8DataRecord[35+(BOOT_u8RecordLength*2)]);
    		/* Restart the buffer */
    		BOOT_u8DataRecord[20] = 0; BOOT_u8DataRecord[21] = 0;
    		/* Ensure that the connection is closed */
    		BOOT_vCloseConnection();
    		/* Increment the counter */
    		BOOT_u8CounterD0 += 2;
    		if (BOOT_u8CounterD0 >= 58) {
    			BOOT_u8CounterD0 -= 10; BOOT_u8CounterD1++;
    			if (BOOT_u8CounterD1 >= 58) { BOOT_u8CounterD1 -= 10; BOOT_u8CounterD2++; }
    		}
    		/* Check if it was the last record received */
    		if (BOOT_u8DataRecord[30] == '1' || BOOT_u8DataRecord[43+(BOOT_u8RecordLength*2)] == '1') {
				/* Set the status of the firmware to old */
    			BOOT_vUpdateFirmwareStatus();
    			BOOT_vJumpToApplicationCode();
    		}
    	}
	}
}

/**
 * @brief Performs a hardware reset sequence for the ESP8266 module.
 *
 * This function toggles the reset pin of the ESP8266 module to perform a hardware reset.
 */
void BOOT_vHWReset(void) {
	MGPIO_vSetPinValue(ESP8266_RESET_PIN, MGPIO_OUTPUT_HIGH);
	MSTK_vBusyWait(ESP8266_RESET_DELAY);
	MGPIO_vSetPinValue(ESP8266_RESET_PIN, MGPIO_OUTPUT_LOW);
	MSTK_vBusyWait(ESP8266_RESET_DELAY);
	MGPIO_vSetPinValue(ESP8266_RESET_PIN, MGPIO_OUTPUT_HIGH);
}

/**
 * @brief Initializes the ESP8266 module by performing necessary startup procedures.
 *
 * This function resets the ESP8266 module using the hardware reset pin,
 * ensures the echo is turned off, and sets the module to station mode (mode 1).
 * It communicates with the ESP8266 module via USART to send commands and receive responses.
 */
void BOOT_vInitESP(void) {
	/* Reset using HW reset pin */
	BOOT_vHWReset();
	/* Close the echoing */
	do {
		BOOT_ContFlag = FAILED_TO_FETCH;
		BOOT_u8TimeOut = 0;
		MUSART_vTransmitString(ESP8266_USART, (u8*)"ATE0\r\n");
		/* Read the buffer */
		while (BOOT_u8TimeOut < BOOT_THRESHOLD_VALUE) {
			MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &BOOT_u8Buffer);
			if (BOOT_u8Buffer == 'O') {                                                /* if 'O', read next element             */
				MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &BOOT_u8Buffer);
				if (BOOT_u8Buffer == 'K') { BOOT_ContFlag = CONTINUE; break; }         /* 'K' means '\r\nOK' --> break          */
			} else if (BOOT_u8Buffer == 'R') {                                         /* if 'R', read the next element         */
				MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &BOOT_u8Buffer);
				if (BOOT_u8Buffer == 'R') { BOOT_ContFlag = FAILED_TO_FETCH; break; }  /* 'K' means '\r\nERROR' --> break       */
			} else if (BOOT_u8Buffer == 'b') { BOOT_vHWReset(); break; }               /* 'b' means 'busy' --> reset the module */
			BOOT_u8TimeOut++;
		}
	} while(BOOT_ContFlag == FAILED_TO_FETCH);
	/* Set to station mode */
	do {
		BOOT_ContFlag = FAILED_TO_FETCH;
		BOOT_u8TimeOut = 0;
		MUSART_vTransmitString(ESP8266_USART,(u8*)"AT+CWMODE=1\r\n");
		/* Read the buffer */
		while (BOOT_u8TimeOut < BOOT_THRESHOLD_VALUE) {
			MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &BOOT_u8Buffer);
			if (BOOT_u8Buffer == 'O') {                                                /* if 'O', read next element             */
				MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &BOOT_u8Buffer);
				if (BOOT_u8Buffer == 'K') { BOOT_ContFlag = CONTINUE; break; }         /* 'K' means '\r\nOK' --> break          */
			} else if (BOOT_u8Buffer == 'R') {                                         /* if 'R', read the next element         */
				MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &BOOT_u8Buffer);
				if (BOOT_u8Buffer == 'R') { BOOT_ContFlag = FAILED_TO_FETCH; break; }  /* 'K' means '\r\nERROR' --> break       */
			} else if (BOOT_u8Buffer == 'b') { BOOT_vHWReset(); break; }               /* 'b' means 'busy' --> reset the module */
			BOOT_u8TimeOut++;
		}
	} while(BOOT_ContFlag == FAILED_TO_FETCH);
}

/**
 * @brief Initializes the system and peripherals required for booting the application.
 *
 * This function performs the following initialization steps:
 * 1. Initializes the system clock.
 * 2. Enables the clock for necessary peripherals including GPIO, Flash memory interface, and ESP8266.
 * 3. Configures GPIO pins for ESP8266 reset and USART communication.
 * 4. Initializes USART communication with ESP8266.
 * 5. Initializes and starts the SysTick timer.
 * 6. Initializes the Flash memory interface.
 * 7. Initializes the ESP8266 module by calling @ref BOOT_vInitESP.
 */
void BOOT_vInit(void) {
	/* Initialize system clock */
	MRCC_vInitSysAndBusClock();
	/* Enable wanted peripherals clock */
	MRCC_vEnablePeriphClock(MRCC_BUS_AHB1, MRCC_AHB1_GPIOAEN);
	MRCC_vEnablePeriphClock(MRCC_BUS_AHB1LP, MRCC_AHB1LP_FLITFLPEN);
	MRCC_vEnablePeriphClock(ESP8266_PERI_CLOCK);
	/* Initialize pins */
	MGPIO_vSetPinMode(ESP8266_RESET_PIN, MGPIO_MODE_OUTPUT);
	MGPIO_vSetPinOutputSpeed(ESP8266_RESET_PIN, MGPIO_LOW_SPEED);
	MGPIO_vSetPinOutputType(ESP8266_RESET_PIN, MGPIO_OUTPUT_TYPE_PP);
	MGPIO_vSetPinValue(ESP8266_RESET_PIN, MGPIO_OUTPUT_HIGH);
	MGPIO_vSetPinMode(ESP8266_USART_TX, MGPIO_MODE_ALTERNATE);
	MGPIO_vSetPinMode(ESP8266_USART_RX, MGPIO_MODE_ALTERNATE);
	MGPIO_vSetPinAFDirection(ESP8266_USART_TX, ESP8266_USART_TX_AF);
	MGPIO_vSetPinAFDirection(ESP8266_USART_RX, ESP8266_USART_RX_AF);
	/* Initialize peripherals */
	MUSART_InitTypeDef uart = ESP8266_USART_INIT_STRUCTURE;
	MUSART_ClockInitTypeDef uart_clock = {MUSART_DISABLE, 0, 0, 0};
	MUSART_vInit(ESP8266_USART, &uart, &uart_clock);
	MUSART_vEnable(ESP8266_USART);
	MUSART_vRxIntStatus(ESP8266_USART, MUSART_DISABLE);
	MSTK_vInit();
	MFMI_vInit();
	/* Initialize ESP8266 */
	BOOT_vInitESP();
}

/**
 * @brief Retrieves the firmware status from the ESP8266 module.
 *
 * This function performs the following steps:
 * 1. Connects to a server using TCP protocol.
 * 2. Sends a request to retrieve firmware status.
 * 3. Parses the response to determine the status ('O' or 'N').
 * 4. Reads the firmware version/address from the response.
 */
void BOOT_vGetFirmwareStatusAndAddress(void) {
	u8 Local_u8Address[8] = {0};
	do {
		/* Connect using TCP protocol */
		do {
			BOOT_ContFlag = FAILED_TO_FETCH;
			BOOT_u8TimeOut = 0;
			MUSART_vTransmitString(ESP8266_USART,(u8*)CIPSTART);
			/* Read the buffer */
			while (BOOT_u8TimeOut < BOOT_THRESHOLD_VALUE) {
				MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &BOOT_u8Buffer);
				if (BOOT_u8Buffer == 'b') { BOOT_vInitESP(); break; }                          /* 'b' means 'busy' --> reset the module   */
				else if (BOOT_u8Buffer == 'O') {                                               /* if 'O', read next element               */
					MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &BOOT_u8Buffer);
					if (BOOT_u8Buffer == 'K') { BOOT_ContFlag = CONTINUE; break; }             /* 'K' means 'CONNECT\r\nOK' --> break     */
					else if (BOOT_u8Buffer == 'R') { BOOT_ContFlag = FAILED_TO_FETCH; break; } /* 'R' means 'ERROR' --> connect again     */
				}
				else if (BOOT_u8Buffer == 'Y') {                                               /* if 'Y', read next element               */
					MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &BOOT_u8Buffer);
					if (BOOT_u8Buffer == ' ') { BOOT_ContFlag = CONTINUE; break; }             /* ' ' means 'ALREADY CONNECTED' --> break */
				}
				BOOT_u8TimeOut++;
			}
		} while(BOOT_ContFlag == FAILED_TO_FETCH);
		/* TCP is now connected */
		do {
			BOOT_ContFlag = FAILED_TO_FETCH;
			BOOT_u8TimeOut = 0;
			MUSART_vTransmitString(ESP8266_USART,(u8*)"AT+CIPSEND=49\r\n");
			/* Read the buffer */
			while (BOOT_u8TimeOut < BOOT_THRESHOLD_VALUE) {
				MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &BOOT_u8Buffer);
				if (BOOT_u8Buffer == 'v') { BOOT_ContFlag = CAN_NOT_SEND; break; }  /* 'v' means 'link is not valid' --> connect again */
				else if (BOOT_u8Buffer == 'O') {                                    /* if 'O', read next element                       */
					MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &BOOT_u8Buffer);
					if (BOOT_u8Buffer == 'K') { BOOT_ContFlag = CONTINUE; break; }  /* 'K' means '\r\nOK' --> break                    */
				} else if (BOOT_u8Buffer == 'b') { BOOT_vInitESP(); break; }        /* 'b' means 'busy' --> reset the module           */
				BOOT_u8TimeOut++;
			}
		} while (BOOT_ContFlag == FAILED_TO_FETCH);
		/* Get status O or N */
		if (BOOT_ContFlag != CAN_NOT_SEND) {
			BOOT_ContFlag = FAILED_TO_FETCH;
			BOOT_u8TimeOut = 0;
			MUSART_vTransmitString(ESP8266_USART,(u8*)"GET http://sobhhhh.freevar.com/FileSettings.txt\r\n");
			/* Read the buffer */
			while (BOOT_u8TimeOut < BOOT_THRESHOLD_VALUE) {
				MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &BOOT_u8Buffer);
				if (BOOT_u8Buffer == '+') {
					MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &BOOT_u8Buffer);
					MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &BOOT_u8Buffer);
					MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &BOOT_u8Buffer);
					MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &BOOT_u8Buffer);
					MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &BOOT_u8Buffer);
					MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &BOOT_u8Buffer);
					MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &BOOT_u8Buffer);
					if (BOOT_u8Buffer == 'N' || BOOT_u8Buffer == 'O') { BOOT_ContFlag = CONTINUE; break; }
				}
				BOOT_u8TimeOut++;
			}
		}
	} while (BOOT_ContFlag == FAILED_TO_FETCH || BOOT_ContFlag == CAN_NOT_SEND);
	/* If N --> new firmware, read the address */
	if (BOOT_u8Buffer == 'N') {
		MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &Local_u8Address[0]);
		MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &Local_u8Address[0]);
		MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &Local_u8Address[1]);
		MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &Local_u8Address[2]);
		MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &Local_u8Address[3]);
		MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &Local_u8Address[4]);
		MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &Local_u8Address[5]);
		MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &Local_u8Address[6]);
		MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &Local_u8Address[7]);
		BOOT_u32Address = SHPR_u32ParseAddress(Local_u8Address);
	}
}

/**
 * @brief Receives a data record from a remote server using the ESP8266 module.
 *
 * This function performs the following steps:
 * 1. Connects to a server using TCP protocol.
 * 2. Sends commands to establish the connection and verify status ('OK', 'ERROR', 'ALREADY CONNECTED').
 * 3. Sends a command to request a specific data record length based on counters (BOOT_u8CounterD2, BOOT_u8CounterD1, BOOT_u8CounterD0).
 * 4. Retrieves the data record from the specified URL using an HTTP GET request.
 * 5. Stores the received data record in BOOT_u8DataRecord.
 *
 * If the module indicates 'busy' or 'link is not valid' during the process, it resets the module.
 * This function communicates with the ESP8266 module using USART.
 */
void BOOT_vReceiveDataRecord(void) {
	do {
		/* Connect using TCP protocol */
		do {
			BOOT_ContFlag = FAILED_TO_FETCH;
			BOOT_u8TimeOut = 0;
			MUSART_vTransmitString(ESP8266_USART,(u8*)CIPSTART);
			/* Read the buffer */
			while (BOOT_u8TimeOut < BOOT_THRESHOLD_VALUE) {
				MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &BOOT_u8Buffer);
				if (BOOT_u8Buffer == 'b') { BOOT_vInitESP(); break; }                          /* 'b' means 'busy' --> reset the module   */
				else if (BOOT_u8Buffer == 'O') {                                               /* if 'O', read next element               */
					MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &BOOT_u8Buffer);
					if (BOOT_u8Buffer == 'K') { BOOT_ContFlag = CONTINUE; break; }             /* 'K' means 'CONNECT\r\nOK' --> break     */
					else if (BOOT_u8Buffer == 'R') {BOOT_ContFlag = FAILED_TO_FETCH ; break; } /* 'R' means 'ERROR' --> connect again     */
				} else if (BOOT_u8Buffer == 'Y') {                                             /* if 'Y', read next element               */
					MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &BOOT_u8Buffer);
					if (BOOT_u8Buffer == ' ') { BOOT_ContFlag = CONTINUE; break; }             /* ' ' neans 'ALREADY CONNECTED' --> break */
				}
				BOOT_u8TimeOut++;
			}
		} while(BOOT_ContFlag == FAILED_TO_FETCH);
		/* TCP is now connected */
		do {
			BOOT_ContFlag = FAILED_TO_FETCH;
			BOOT_u8TimeOut = 0;
			if (BOOT_u8CounterD2 != '0')      { MUSART_vTransmitString(ESP8266_USART,(u8*)"AT+CIPSEND=52\r\n"); }
			else if (BOOT_u8CounterD1 != '0') { MUSART_vTransmitString(ESP8266_USART,(u8*)"AT+CIPSEND=51\r\n"); }
			else 							  { MUSART_vTransmitString(ESP8266_USART,(u8*)"AT+CIPSEND=50\r\n"); }
			/* Read the buffer */
			while (BOOT_u8TimeOut < BOOT_THRESHOLD_VALUE) {
				MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &BOOT_u8Buffer);
				if (BOOT_u8Buffer == 'v') { BOOT_ContFlag = CAN_NOT_SEND; break; }    /* 'v' means 'link is not valid' --> connect again */
				else if (BOOT_u8Buffer == 'O') {                                      /* if 'O', read next element                       */
					MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &BOOT_u8Buffer);
					if (BOOT_u8Buffer == 'K') { BOOT_ContFlag = CONTINUE; break; }    /* 'K' means '\r\nOK' --> break                    */
				} else if (BOOT_u8Buffer == 'b') { BOOT_vInitESP(); break; }          /* 'b' means 'busy' --> reset the module           */
				BOOT_u8TimeOut++;
			}
		} while (BOOT_ContFlag == FAILED_TO_FETCH);
		if (BOOT_ContFlag != CAN_NOT_SEND) {
			MUSART_vTransmitString(ESP8266_USART,(u8*)"GET http://sobhhhh.freevar.com/script.php?line=");
		    if (BOOT_u8CounterD2 != '0') { /* 3 digits */
		    	MUSART_vTransmitByte(ESP8266_USART, BOOT_u8CounterD2);
		        MUSART_vTransmitByte(ESP8266_USART, BOOT_u8CounterD1);
		        MUSART_vTransmitByte(ESP8266_USART, BOOT_u8CounterD0);
		    } else if (BOOT_u8CounterD1 != '0') { /* 2 digits */
		    	MUSART_vTransmitByte(ESP8266_USART, BOOT_u8CounterD1);
		        MUSART_vTransmitByte(ESP8266_USART, BOOT_u8CounterD0);
		    } else { /* 1 digit */
		    	MUSART_vTransmitByte(ESP8266_USART, BOOT_u8CounterD0);
		    }
		    MUSART_vTransmitString(ESP8266_USART,(u8*)"\r\n");
		    /* Receive the data records */
		    MUSART_vReceiveStringSynchBlocking(ESP8266_USART, BOOT_u8DataRecord);
		}
	} while (BOOT_u8DataRecord[21] != ':' && BOOT_u8DataRecord[22] != ':');
}

/**
 * @brief Closes the TCP connection with the remote server using the ESP8266 module.
 *
 * This function sends the AT command "AT+CIPCLOSE\r\n" to close the TCP connection.
 * It waits for a response from the ESP8266 module to determine the success or failure of the operation.
 * Possible responses include:
 * - "OK": Indicates successful closure of the connection.
 * - "ERROR": Indicates an error occurred during the connection closure.
 * - "busy": Indicates the module is currently busy.
 *
 * If the response is "OK" or "ERROR", BOOT_u8ContFlag is set to 1 to exit the loop and complete the function.
 * If the response is "busy", the function resets the ESP8266 module using BOOT_vInitESP().
 */
void BOOT_vCloseConnection(void) {
	do {
		BOOT_ContFlag = FAILED_TO_FETCH;
		BOOT_u8TimeOut = 0;
		MUSART_vTransmitString(ESP8266_USART, (u8*)"AT+CIPCLOSE\r\n");
	    /* Read buffer */
	    while (BOOT_u8TimeOut < BOOT_THRESHOLD_VALUE) {
	    	MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &BOOT_u8Buffer);
	    	if (BOOT_u8Buffer == 'O') {                                            /* if 'O', read Next Element             */
	    		MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &BOOT_u8Buffer);
	    		if (BOOT_u8Buffer == 'K') { BOOT_ContFlag = CONTINUE; break; }     /* 'K' means '\r\nOK' --> break          */
	    	} else if (BOOT_u8Buffer == 'E') {                                     /* if 'E', read next element             */
	    		MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &BOOT_u8Buffer);
	    		if (BOOT_u8Buffer == 'R') { BOOT_ContFlag = CONTINUE; break; }     /* 'R' means '\r\nERROR' --> break       */
	    	} else if (BOOT_u8Buffer == 'b') { BOOT_vInitESP(); break; }           /* 'b' means 'busy' --> reset the module */
	    	BOOT_u8TimeOut++;
	    }
	} while (BOOT_ContFlag == FAILED_TO_FETCH);
}

/**
 * @brief Updates the firmware status by connecting to a remote server via TCP using the ESP8266 module.
 *
 * This function performs the following steps:
 * 1. Connects to the server using TCP protocol and verifies the connection status ('OK', 'ERROR', 'ALREADY CONNECTED').
 * 2. Sends a command to the server to signal readiness to receive data (AT+CIPSEND=<length>).
 * 3. Sends a GET request to retrieve firmware update status from a specific URL.
 * 4. Handles responses such as 'OK' or 'busy' from the server.
 * 5. Closes the TCP connection once the firmware status update process is complete.
 *
 * If the ESP8266 module indicates 'busy' or 'link is not valid' during the process,
 * the module is reset using BOOT_vInitESP().
 */
void BOOT_vUpdateFirmwareStatus(void) {
	do {
		/* Connect using TCP protocol */
		do {
			BOOT_ContFlag = FAILED_TO_FETCH;
			BOOT_u8TimeOut = 0;
			MUSART_vTransmitString(ESP8266_USART,(u8*)CIPSTART);
			/* Read the buffer */
			while (BOOT_u8TimeOut < BOOT_THRESHOLD_VALUE) {
				MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &BOOT_u8Buffer);
				if (BOOT_u8Buffer == 'b') { BOOT_vInitESP(); break; }                 /* 'b' means 'busy' --> reset the module   */
				else if (BOOT_u8Buffer == 'O') {                                      /* if 'O', read next element               */
					MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &BOOT_u8Buffer);
					if (BOOT_u8Buffer == 'K') { BOOT_ContFlag = CONTINUE; break; }    /* 'K' means 'CONNECT\r\nOK' --> break     */
				} else if (BOOT_u8Buffer == 'Y') {                                    /* if 'Y', read next element               */
					MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &BOOT_u8Buffer);
					if (BOOT_u8Buffer == ' ') { BOOT_ContFlag = CONTINUE; break; }    /* ' ' means 'ALREADY CONNECTED' --> break */
				}
				BOOT_u8TimeOut++;
			}
		} while(BOOT_ContFlag == FAILED_TO_FETCH);
		/* TCP is now connected */
		do {
			BOOT_ContFlag = FAILED_TO_FETCH;
			BOOT_u8TimeOut = 0;
			MUSART_vTransmitString(ESP8266_USART,(u8*)"AT+CIPSEND=49\r\n");
			/* Read the buffer */
			while (BOOT_u8TimeOut < BOOT_THRESHOLD_VALUE) {
				MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &BOOT_u8Buffer);
				if (BOOT_u8Buffer == 'v') { BOOT_ContFlag = CAN_NOT_SEND; break; } /* 'v' means 'link is not valid' --> connect again */
				else if (BOOT_u8Buffer == 'O') {                                   /* if 'O', read next element                       */
					MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &BOOT_u8Buffer);
					if (BOOT_u8Buffer == 'K') { BOOT_ContFlag = CONTINUE; break; } /* 'K' means '\r\nOK' --> break                    */
				}  else if (BOOT_u8Buffer == 'b') { BOOT_vInitESP(); break; }      /* 'b' means 'busy' --> reset the module           */
				BOOT_u8TimeOut++;
			}
		} while (BOOT_ContFlag == 0);
		/* Length is now sent, start sending data */
		if (BOOT_ContFlag != CAN_NOT_SEND) {
			BOOT_ContFlag = FAILED_TO_FETCH;
			BOOT_u8TimeOut = 0;
			MUSART_vTransmitString(ESP8266_USART,(u8*)"GET http://sobhhhh.freevar.com/script.php?end\r\n");
			/* Read the buffer */
			while (BOOT_u8TimeOut < BOOT_THRESHOLD_VALUE) {
				MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &BOOT_u8Buffer);
				if (BOOT_u8Buffer == 'O') {                                            /* if 'O', read next element             */
					MUSART_u8ReceiveByteSynchBlocking(ESP8266_USART, &BOOT_u8Buffer);
					if (BOOT_u8Buffer == 'K') { BOOT_ContFlag = CONTINUE; break; }     /* 'K' means '\r\nOK' --> break          */
				}  else if (BOOT_u8Buffer == 'b') { BOOT_vInitESP(); break; }          /* 'b' means 'busy' --> reset the module */
				BOOT_u8TimeOut++;
			}
		}
	} while (BOOT_ContFlag == FAILED_TO_FETCH || BOOT_ContFlag == CAN_NOT_SEND);
	BOOT_vCloseConnection();
}

/**
 * @brief Jumps to the application code located at the specified address.
 *
 * This function performs the following steps:
 * 1. Sets the Main Stack Pointer (MSP) to the value stored at BOOT_u32Address.
 * 2. Sets the vector table offset to the beginning of the application code (0x08004000).
 * 3. Retrieves the address of the reset handler from BOOT_u32Address and jumps to it.
 */
void BOOT_vJumpToApplicationCode(void) {
	/* Set the MSP */
	u32 MSP_VALUE = *((volatile u32*)BOOT_u32Address);
	__asm volatile("MSR MSP,%0"::"r"(MSP_VALUE));
	/* Set the vector table */
	*((volatile u32*) 0xE000ED08) = BOOT_u32Address;
	/* Jump to the reset handler of the application code */
	void (*JUMP_TO_APPLICATION_CODE)(void);                                    /* Create a pointer to function                 */
	JUMP_TO_APPLICATION_CODE = (void*)(*((volatile u32*)BOOT_u32Address + 4)); /* Point it to the address of the reset handler */
	JUMP_TO_APPLICATION_CODE();                                                /* Jump to the reset handler                    */
}
